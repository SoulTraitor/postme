# Testing Patterns

**Analysis Date:** 2026-02-11

## Test Framework

**Runner:**
- Frontend: Not detected - No Jest, Vitest, or other test runner configured
- Backend: Not detected - No Go testing framework configured
- Build system uses `vue-tsc --noEmit` for type checking only

**Assertion Library:**
- Not applicable - No test suite present

**Run Commands:**
```bash
npm run dev              # Run frontend dev server (no tests)
npm run build           # Build frontend (includes type checking via vue-tsc)
go build                # Build backend (no tests)
```

## Test File Organization

**Location:**
- No test files found in `internal/` directory
- No `.test.ts` or `.spec.ts` files in `frontend/src/`
- Test files only exist in node_modules (third-party packages)

**Naming:**
- Not applicable - No tests present in codebase

**Structure:**
- Not applicable - No tests present in codebase

## Type Safety as Quality Gate

**TypeScript Configuration:**
- `strict: true` in `tsconfig.json` enables all strict type-checking options
- `noEmit: true` - TypeScript used for type checking only, not transpilation
- Build command: `npm run build` runs `vue-tsc --noEmit` before Vite build
  - Prevents builds with type errors
  - Enforces type safety on all Vue components and TypeScript files

**Vite Build:**
- `vue-tsc --noEmit && vite build` - Type check first, then build
- Fails build if TypeScript compilation has errors
- Ensures all Vue components with `<script setup lang="ts">` are type-checked

**Go Testing:**
- No formal testing framework
- Error handling via `if err != nil` checks at call sites
- Type safety via Go's static typing and interfaces

## Error Handling Patterns

**Frontend Error Handling:**
```typescript
try {
  const api = await getApi()
  await api.setSidebarItemExpanded(itemType, itemId, newValue)
} catch (error) {
  console.error('Failed to save sidebar state:', error)
}
```
- All Wails API calls wrapped in try-catch
- Errors logged with contextual message
- Non-critical failures don't break UI (graceful degradation)
- Database lock retries with exponential backoff:
  ```typescript
  try {
    // Save state
  } catch (error) {
    if (error.toString().includes('database is locked')) {
      console.warn('Database locked, retrying in 500ms...')
      // Schedule retry
    }
  }
  ```

**Backend Error Handling:**
```go
func (r *CollectionRepository) Create(collection *models.Collection) error {
  result, err := r.db.Exec(`...`, ...)
  if err != nil {
    return err
  }
  // ...
  return nil
}
```
- All database operations return error as second value
- Errors propagated up to handler layer
- Handlers return error to frontend for display
- Handler example:
  ```go
  func (h *RequestHandler) Create(req models.Request) (*models.Request, error) {
    if err := h.service.Create(&req); err != nil {
      return nil, err
    }
    return &req, nil
  }
  ```

**Critical Failures:**
- Window restoration position validation prevents invisible windows:
  ```go
  if x >= -100 && x < 10000 && y >= -100 && y < 10000 {
    runtime.WindowSetPosition(ctx, x, y)
  }
  ```
- Window size validation prevents invalid dimensions:
  ```go
  if !isMaximized && !isMinimized && w >= 800 && h >= 600 && x >= -100 && y >= -100 {
    // Save dimensions
  }
  ```

## Mocking

**Framework:** Not applicable - No testing framework

**Strategy:**
- No mocking in codebase
- Frontend uses Wails IPC directly to backend
- Type-safe bindings auto-generated by Wails in `wailsjs/`
- Backend uses sqlx database abstraction (interfaces available for mocking if tests added)

## Fixtures and Test Data

**Test Data:**
- No fixtures or test data files present
- Constants defined in `internal/models/constants.go` serve as configuration:
  ```go
  const (
    MaxHistoryRecords = 100
    WindowResizeDebounce = 500
    ContentEditDebounce = 1000
    DefaultWindowWidth = 1200
    DefaultWindowHeight = 800
    DefaultSidebarWidth = 260
    DefaultSplitRatio = 50
    DefaultRequestTimeout = 30.0
  )
  ```

**Location:**
- Not applicable - No test fixtures

## Coverage

**Requirements:** Not enforced

**Metrics:** Not tracked

**Current State:** No test suite; type checking via `vue-tsc --noEmit` provides static analysis coverage

## Test Types

**Unit Tests:**
- Not implemented
- Recommendation: Add tests for data transformation functions (e.g., `convertKeyValue()`, `convertRequest()` in `src/services/api.ts`)
- Go services (`internal/services/`) would benefit from unit tests for HTTP client logic

**Integration Tests:**
- Not implemented
- Frontend integration with Wails backend relies on manual testing
- Example candidates: Request execution flow, database operations in repositories

**E2E Tests:**
- Not detected or implemented
- Would require Wails testing harness or browser automation

## Quality Assurance Approach

**Type Safety First:**
- Build fails if TypeScript has errors: `vue-tsc --noEmit && vite build`
- All Vue components use `<script setup lang="ts">` with type-safe props/emits
- TypeScript strict mode catches:
  - Null/undefined access issues
  - Type mismatch in function calls
  - Unused variables
  - Missing properties in objects

**Manual Testing:**
- Frontend tested via Wails development server
- Navigation, state management, API calls tested manually
- Performance logging in App.vue tracks initialization time

**What's Tested Implicitly:**
- Type definitions prevent common bugs in data structures
- TypeScript interfaces catch API contract violations between frontend and backend
- Wails binding generation catches handler signature mismatches
- Tailwind CSS classes validated at build time

**What's NOT Tested:**
- HTTP client error handling (`internal/services/http_client.go`)
- Database transaction rollback logic
- Complex UI interactions (drag-drop, resize, modal stacking)
- Edge cases in state synchronization
- Concurrent request cancellation

## Adding Tests (Guidance for Future)

**Frontend Testing:**
1. Add Vitest + Vue Test Utils for component testing
2. Create test files alongside components: `Component.test.ts`
3. Test data transformation in services:
   - `src/services/api.ts` conversion functions (convertRequest, convertResponse, etc.)
4. Test Pinia stores state mutations and actions

**Backend Testing:**
1. Add Go testing via `*_test.go` files in `internal/`
2. Start with repository layer tests (mock sqlx.DB)
3. Add HTTP client tests for various content types and error conditions
4. Test handler layer for proper error propagation

**Example Backend Test Pattern:**
```go
// internal/database/repository/collection_repo_test.go
func TestCreateCollection(t *testing.T) {
  // Setup
  db, mock := setupMockDB(t)
  repo := NewCollectionRepository(db)

  // Test
  col := &models.Collection{Name: "Test"}
  err := repo.Create(col)

  // Assert
  if err != nil {
    t.Fatalf("unexpected error: %v", err)
  }
}
```

**Example Frontend Test Pattern:**
```typescript
// src/services/api.test.ts
import { describe, it, expect } from 'vitest'
import { convertRequest } from './api'
import type { models } from '../wailsjs/go/models'

describe('API converters', () => {
  it('should convert Request model to frontend type', () => {
    const input = {
      id: 1,
      name: 'Test',
      method: 'GET',
      url: 'http://example.com'
    }
    const result = convertRequest(input as models.Request)
    expect(result.id).toBe(1)
    expect(result.method).toBe('GET')
  })
})
```

---

*Testing analysis: 2026-02-11*
